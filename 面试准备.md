面试准备

1.自我介绍90s-120s

我叫李帅男，重庆邮电大学机器人工程专业的

2.项目中的难点，如何解决的       

双轮平衡小车中的难点：小车不平衡，电路烧坏

3.iic,uart,spi总线，自己的理解和项目涉及到的模块

UART,全双工模式，三根线，TX，RX，GND 主机和从机

SPI，全双工同步，一个主机多个从机，SDI,SDO,SCK,CS

IIC，半双工 一根线SCL,SDA，时序比较严格

Robocon项目中的难点 ，1点就是24v降5v

同济研究院公司面试：

他不知道你的简历

有没有用过DMA中断怎么解决

IIC是硬件IIC和软件IIC

有没有焊接过电路

UART协议使用细讲

单片机的外设

裸机跑还是freertos



c语言部分

```
1.请填写bool , float,  指针变量 与“零值”比较的if语句。
提示：这里“零值”可以是0, 0.0 , FALSE  或者“空指针”。
例如int 变量 n 与“零值”比较的 if 语句为：
 if ( n = =0 )  if ( n != 0 )  以此类推。 

```

```c
if(!n) ,if(n) "bool型"
"float型"
const float flag=0.00001
 if(x>=-flag && x<=flag)
 "指针型"
if(p==NULL) if(!p==NULL)
```

```c
2.以下为Linux下的32 位C 程序，请计算sizeof 的值。
char  str[] = “Hello” ;                               
char   *p = str ;                                      
int   n = 10;                                               
请计算
（1）sizeof ( str ) =    6    "别忘了 /0 字符串结尾"          
（2）sizeof ( p ) =      4     "数组指针传入的是首地址"         
（3）sizeof ( n ) =		4     "整数占四个字节"
（4）void Func ( char str[100])                           
{                                          
	…… ;                                                            
}                                          
请计算sizeof( str ) =   4                 
"数组作为参数传入函数内，其实传入的是首地址，所以还是求的指针（即地址）大小"
（5）void *p=malloc(100);
sizeof( p )=     4

```



```c
4.用变量a 给出下面的定义
e) 一个有10个指针的数组，该指针是指向一个整型数的;
f)  一个指向有10个整型数数组的指针;
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数;
h) 一个有10个指针的数组，每个指针指向一个函数，该函数有一个整型参数并返回一个整型数;

```

```c
int *a[10];
int (*a)[10];
int (*a)(int);
int (*a[10])(int)
"只有第一个知道剩下的都不太清楚"
```

```c
5. 设有以下说明和定义：
typedef union 
{
	long i; 
	int k[5]; 
	char c;
} DATA;
struct data 
{ 
	int cat; 
	DATA cow; 
	double dog;
} too;
DATA max;
则语句printf("%d",sizeof(struct data)+sizeof(max)); 的执行结果
```

```c
DATA作为一个union 变量公共空间 最大的变量类型是int[5] 
也就是 4*5=20
struct作为一个结构体 cat=4 cow=20 double=8
那么too=32 max=20 最后结果是52
```

```c
6.请问以下代码有什么问题：
int main()
{
char a;
char *str=& a;
strcpy(str,"hello");
printf(str);
return 0;
}
```

```c
char *str=& a;
这里的错误是str是一个指针变量但是被赋值一个字符串 ，&是取地址的符号
strcpy(str,"hello");
将字符串复制进一个字符变量指针的地址
```

```c
int* p;
p = &a;	  //这种方式正确
printf("p = %d\n",p);

所以可不可以理解
&p是一个取地址的符号
*p是一个解引用的符号
    
```

```c
7.请问以下代码有什么问题：
char * s ="AAA";
printf("%s",s );
s[0]='B';
printf("%s",s);
有什么错？
"答：‘AAA’是一个字符串常量 s是一个指针变量 const char *s=‘AAA’才正确"
```

```
补充const关键字的知识
关键字const用来定义常量
C语言中不是有#define吗，干嘛还要用const呢

与预编译指令相比，const修饰符有以下的优点：

1、预编译指令只是对值进行简单的替换，不能进行类型检查

2、可以保护被修饰的东西，防止意外修改，增强程序的健壮性

3、编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。
```

```c
const是一个常量指针
const int * n;
int const * n;

常量指针说的是不能通过这个指针改变变量的值，但是还是可以通过其他的引用来改变变量的值的。
    
指针常量，不能在指向其他的地址
int *const n;

需要注意的是，指针常量指向的地址不能改变，但是地址中保存的数值是可以改变的，可以通过其他指向改地址的指针来修改。

```

```c
int (*s[10])(int) 函数指针数组，每个指针指向一个int func ( int param) 的函数。（或一个有10个指针的数组，每个指针指向一个函数，该函数有一个整型参数并返回一个整型数）
```

```
9.c和c++ 中的struct有什么不同？
c里面的struct不含有成员参数，而c++是可以的
c++中class和struct分别是public，class默认是private
```

```
malloc 不能传递动态内存
```

```c
11.char szstr[10];
strcpy(szstr,"0123456789");
产生什么结果？为什么？
```

12.数组和链表的区别？

```c
答案：
数组：数据顺序存储，固定大小；
链表：数据可以随机存储，大小可动态改变。
```

13.

```c
13.void main()
{
	char aa[10];
	printf(“%d”,strlen(aa));
}                                          
会出现什么问题？打印结果是是多少？
```

```
sizeof()和初始化没有关系
strlen()和初始化有关
```

```
char 一个字节
int  四个字节
float 四个字节
double 八个字节
unsigned int 四个字节
short 两个字节
```

```c
14.给定结构
struct A
{
	char t:4;
	char k:4;
	unsigned short i:8;
	unsigned long m;
}; 问sizeof(A) = ?
   这里不懂： 什么叫字节对齐
```

```c
17.程序哪里有错误
wap( int *p1,int *p2 )
{
	int  *p;
	*p = *p1;
	*p1 = *p2;
	*p2 = *p;
}
```

这里说是声明了一个野指针 方法int *p=NULL

```c
19.(void *)ptr 和(*(void**))ptr 的结果是否相同？其中ptr为同一个指针。
结果相同 *相当于一个解引用的操作
```

```c
20.要对绝对地址0x100000赋值，我们可以用
(unsigned int*)0x100000 = 1234;
那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？

(void (*)())0x100000 
然后再调用它: 
*((void (*)())0x100000)(); 
```

```c
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
```

```c
29.头文件中的ifndef/define/endif 干什么用？
    防止头文件被重复引用
```

```c
在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
int main(void)
{
    int *ptr;
    ptr=(int*)0x67a9;
    *ptr=0xaa66;
}
```

```c
30.#include  <filename.h>    和	#include  “filename.h” 有什么区别？
对于尖括号从标准库开始搜索
对于冒号从工作路径开始搜索
    
```

```c
32.static有什么用途？（请至少说明两种）

1 限制变量的作用域（static全局变量）；
2 设置变量的存储域（static局部变量）。
```

33.堆栈溢出一般是由什么原因导致的？

面试 佰维存储

问了项目问题项目中出现的bug以及相关的定位，说实话这方面的能力很欠缺

项目中代码出错定位

局部变量存储的位置

有没有用过队列

有没有用过指针，什么样的函数要用指针跑

STM32中的CPU单元是什么一脸懵逼

git上面有没有阅读过大型程序的源码，。

面试体会：

百维面试时候说了，注重代码bug的定位能力，自己对项目代码其实是忘记很多了，也可以是基本上是什么都没有准备了，如果准备的话我感觉还是得

1.去做一做实际大型的项目，

2.去读一些源码，

3.还有数据结构在嵌入式的应用可以去看一看

收货还是蛮大的，但是最近的精力还是放在毕业设计上面吧，该复习的还得复习



有时间去看看c++中的一些代码

python的也要看一看，数据结构方面的知识忘得真的很多



补充:什么时候用指针？

答：1.需要改变实参的时候, 只能用指针.
2. 传递大型结构并且"只读"其元素的时候, 
因为大型结构通过值传递, 需要拷贝其每个元素, 这样效率太低.
3. 需要遍历数组或频繁引用其元素时, 这样效率比使用下标高.
4. 动态分配空间时, 必须使用指针.
5. 传递数组时, 必须使用指针.
6. 函数返回指针时, 比如fopen[object Object]





英飞源面试

这次面试感觉很顺利，但是对公司的整体感觉不是特别好，或者说感觉不是很严肃？主要是两个方面：首先是HR在周末准备面试，但是又把我给鸽掉了，感觉管理不是很好，技术主管面试的时候，感觉也不是很好，问的问题没有很深入，问我有没有学过数据结构，但是又不是很深入的问，而且好像不是主管在面试

问的问题

​	有没有做过电路方面的知识

​	有没有上过数据结构这门课

​	会不会看参数手册

​	他主要在介绍公司的一些情况

​	项目中的一些问题

​	有没有用过结构体

​	有没有看过单片机启动的一些源码

------

1.项目中结构体的使用

（1）.struct可以用于数据包的处理

```c
/* 微信公众号：嵌入式大杂烩 */
enum DATA_PKG_TYPE
{
    DATA_PKG1 = 1,
    DATA_PKG2,
    DATA_PKG3    
};
 
struct data_pkg1
{
    // ...
};
 
struct data_pkg2
{
    // ...
};
 
struct data_pkg3
{
    // ...
};
 
struct data_pkg
{
    enum DATA_PKG_TYPE data_pkg_type;
    union 
    {
       struct data_pkg1 data_pkg1_info;
       struct data_pkg2 data_pkg2_info;
       struct data_pkg3 data_pkg3_info;
    }data_pkg_info;
};
```

解释：在进行包处理时对data_pkg_type进行判断确定数据包的类型，在给对应的union的结构体进行赋值

(2).寄存器的封装

![](面试准备.assets/union_struct.png) 

所有的寄存器被封装成联合体类型的，联合体里边的成员是一个`32bit`的整数及一个结构体，该结构体以位域的形式体现。这样就可以达到直接操控寄存器的某些位了。比如，我们要设置`PA0`引脚的`GPAQSEL1`寄存器的`[1:0]`两位都为1，则我们只操控两个`bit`就可以很方便的这么设置：

```c
GpioCtrlRegs.GPAQSEL1.bit.GPIO0 = 3
#使用位域进行操作
GpioCtrlRegs.GPAQSEL1.all |=0x03 

```

[嵌入式结构体和联合体使用]: https://blog.csdn.net/zhengnianli/article/details/111503438

